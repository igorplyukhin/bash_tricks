## Unix Course tasks

1. Напишите команду, которая подсчитает число строк во всех файлах  каталога /etc (без заглядывания в подкаталоги). Используйте символ * для подстановки имен всех файлов (и подкаталогов) в каталоге в командную строку. Об ошибках, которые  будут выдаваться когда вместо имени файла в программу подсчета строк (или подобную) будет подано имя каталога, можно не заботиться.\
`cat /etc/* | wc -l`
2. Напишите команду, которая выведет в две колонки информацию о файлах в каталоге /lib. В первой колонке имена файлов, во второй  размеры. Разделитель точка с запятой.  Получившийся список должен быть отсортирован по размеру файлов от больших к меньшим. Используйте awk, ls, sort. Каталоги можно обрабатывать так же как и файлы, а можно их как-то отфильтровать.\
`ls -l /lib/ | grep -v "drwxr" | tail -n +2 | awk '{print $9" ; "$5}' | sort -rnk3`
3. В файле todelete.txt находится список файлов на удаление с абсолютными путями по одному в строке без переводов строки внутри имени. Удалите файлы с помощью xargs и rm. Особое внимание обратите  на имена файлов с пробелами. Попробуйте применить команду tr '\n' '\000'\
`cat todelete.txt | xargs -d "\n"  rm -rf`
4. Напишите программу, которая будет проверять то, что переменная LOCF не пуста и файл $LOCF не существует в этом случае программа должна создать файл $LOCF
(можно использовать или не использовать if)\
`[ "$LOCF" "!=" "" ] && [ ! -f "$LOCF" ] && touch $LOCF`
5. В переменной D находится целое положительное число. Напишите с помощью арифметической подстановки и операторов ||, &&, () программу FizzBuzz. Если число кратно трем, программа должна выводить слово Fizz,  кратно пяти — слово Buzz. Если число кратно и трём и пяти, то программа должна выводить слово FizzBuzz\
`[ $(("$D" % 3)) = 0 ] && echo -n "Fizz"; [ $(("$D" % 5)) = 0 ] && echo -n "Buzz"`
6. Смоделируйте ситуацию с конвейером cmd1 | cmd2, которая позволит выяснить, какой будет общий код ответа если первая команда вернула ошибку, а вторая завершилась успешно. В ответ впишите команду которую вы использовали для проверки в виде ЧТО-ТО; echo $?. Подсказка: можно использовать команды, которые ничего не пишут и не читают, на код завершения это не повлияет.\
`false | true; echo $?`
7. Напишите скрипт для определения максимального числа с которыми работает арифметическая подстановка (())  Скрипт должен выводить большое число. Можно приблизительно, т.е. максимум не меньше напечатанного.
```
#!/bin/bash
x=2
xprev=0
while :
do
    xprev=$x
    x=$(( $x * 2))
    echo $x
    if [[ $x -le 0 ]]
    then
        x=$xprev
        a=$( expr length $x - 1 )
        while [[ $a -ge 0 ]]
        do  
            xprev=$x
            x=$(( $x + 10 ** $a ))
            if [[ $x -le 0 ]]
            then 
                x=$xprev
                a=$(( $a-1 ))
                continue
            fi
            echo $x
        done
        break
    fi
    
done

echo "Maximum is $x"
```
8. Напишите скрипт, который переименует все файлы  в текущем каталоге, переведя имена в верхний регистр. В именах только латиница. Для смены регистра можно использовать команду tr, или подстановку в переменной, или что-нибудь ещё.\
`for f in * ; do mv -- "$f" "$(tr [:lower:] [:upper:] <<< "$f")" ; done`
9. Напишите команду grep, которая удалит все пустые (совсем пустые или заполненные пробелами и знаками табуляции) строки\
`cat 1.txt | grep -v "^[[:space:]]*$"`
10. Попробуйте с помощью калькулятора bc выдать число Пи с точностью 1000 знаков. Пример, конечно, есть в википедии, но вам надо записать его в одну строку и командой time замерить время выполнения\
`time echo "scale=1000; 4*a(1)" | bc -l`
11. Напишите команду c использованием sed, которая удалит из html все теги, заменяя их на перевод строки, а потом удалит пустые строки\
`cat 1.txt | sed -e 's/<[^>]*>//g' | sed '/^[[:space:]]*$/d'`
12. Программа ps не очень стандартизована, но во всех реализациях есть возможность выдать имя или UID пользователя-владельца процесса (ps axu в Linux, просто ps в cygwin и mingw). Напишите скрипт, который в вашей системе выдаёт список всех пользователей, у которых сейчас есть запущенные процессы и количество этих процессов у каждого из них. Одна строка - один пользователь. Можно задействовать опцию форматирования в ps (если она есть в вашей версии) и awk для выделения столбцов.\
`ps aux | awk '{d[$1]=d[$1]+1} END {for (k in d) {print k ": " d[k]}}'`
13. Подготовьте файл со списком имен пользователей вашей системы. В Linux можно использовать стандартный файл из каталога /etc/. В других системах можно создать подобный файл самостоятельно. Используя команду ps и этот файл  напишите скрипт, выдающий список имен пользователей у которых сейчас не запущено ни одного процесса.\
```
cat /etc/passwd | cut -d ":" -f 1 > users.txt &&
ps aux | awk '{print $1}' | sort | uniq > users_with_processes.txt &&
sort users.txt users_with_processes.txt | uniq -u
```
14. Используя команды: wc –l , cut (или awk), head, tail и цикл for напишите скрипт, который выводит на экран текстовый файл задом наперед (вначале последняя строка, потом предпоследняя и т.д).  Имя файла можно занести в переменную или явно подставлять там, где надо. (Примечание: 1. В Unix есть стандартная  команда tac, которая выполняет нужное преобразование, но её использование будем считать неспортивным; 2. В awk можно считать весь файл в массив и потом распечатать. Я зачту, но хотелось бы решение, требующее меньшего количества оперативной памяти)\
`for i in $(seq $(cat $file | wc -l) -1 1); do head -n $i $file | tail -1; done`
15. Команда cmd1 | ssh user@host cmd2 связывает STDOUT cmd1 с STDIN cmd2, которая выполняется в домашнем каталоге пользователя user на компьютере host. Напишите, как с помощью ssh рекурсивно скопировать каталог ~/src локальной машины в каталог ~/dst удаленной, сохранив все атрибуты файлов (кроме ctime). Если у вас нет сервера, на который можно подключаться по ssh, то можно сымитировать ситуацию локально без ssh: cmd1| cmd2\
`cd ~/src && tar -c . | ssh user@host tar -xv -C ~/dst`
16. Напишите скрипт, который будет архивировать в tar каталог ~/work. По числам, заканчивающимся на 2 (2, 12, 22), каталог архивируется  целиком, а в остальные дни месяца только файлы, изменившиеся с 00 часов предыдущего дня. Имена архивов YYYY-mm-dd_work_full_tgz и YYYY-mm-dd_work_daily_tgz, где YYY-mm-dd это дата архивирования. Текущую дату можно получить командой date +%Y-%m-%d\
```
#!/bin/bash
cd ~
tardir="work"
yesterday=$(date -d "yesterday 00:00" '+%Y-%m-%d %H:%M')
today=$(date +%Y-%m-%d)

if [ "${today: -1}" -eq "2" ]; then
    tar -czvf "${today}_work_full.tgz" $tardir
else
    tar -czvf "${today}_work_daily.tgz" --newer="${yesterday}" $tardir
fi
```
17. В дополнение к заданию 8 — gzip a.txt; cat img.jpg a.txt.gz > img1.jpg; rm a.txt.gz напишите программу, которая найдет в файле img1.jpg спрятанный архив и распакует его\
`dd if=img1.jpg of=a.txt.gz bs=1 skip=$(wc -c < img.jpg) && gunzip a.txt.gz`
```

s=$(ls -l img1.jpg | awk '{ print $5 }')
for (( i=0; i<=s; i++ )); do
    dd if=img1.jpg of=a.txt.gz bs=1 skip=$i
    if gunzip -f a.txt.gz; then break; fi
done
```
18.


